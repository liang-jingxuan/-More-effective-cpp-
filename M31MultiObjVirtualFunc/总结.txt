1.需求:
    继承自同一基类的同等级子类中，任意两个子类的互动结果互不相同。
2.场景:
    比如有4个继承同一个基类的同等级子类 A,B,C,D四个类，A和B的互动结果 与 A和C的互动结果不同，
任意两个子类的互动结果互不相同
3.没法改变的点(难点):
    这种情况下，若增加一个子类E，就要在已有的子类（A,B,C,D）内对应增加针对E类的函数，
并在E类内增加对已有子类(A,B,C,D)类的函数
4.实现需求,并在实现的基础上减少3中所提到的工作量,

实现方法1: if-else和RTTI的运用（代码中的Red类）[这种方法没有跳转]

    RTTI（Run-Time Type Identification，运行时类型识别）,可以识别出正在使用的变量的类型
    使用typeid(obj).name()得到变量的类型的名字,然后对每个类型进行处理

    伪代码:
        const 基类& objType=typeif(obj);
        if(typeif(A)==objType) {...}
        else if(typeif(B)==objType){...}
        ...
        else
            throw notExisttype();

    缺点:即难点3,没增加一个类,就要在已有的类中加一个else if,并在新的类里每个互动成员函数实现这样的if-else逻辑

实现方法2:使用虚函数+重载虚函数实现二次调度(代码中的Green类)[这种方法实现类间跳转]
    具体的,对于互动成员函数fun,使用参数为基类的fun函数进行转移（跳转函数）,转移到同类中参数正确的互动函数（实现函数）

    (C是一个子类，obj是C类对象) obj.fun(子类)->C::fun(基类)->C::fun(子类)

    伪代码：
        转移函数
        fun(基类 &otherColor){
            otherColor.fun(*this);
        }
        重载的具体的互动函数
        fun(子类1 & obj){//如何处理和子类1的互动}
            ...
        fun(子类N & obj){//如何处理和子类N的互动}
    相比于实现方法1，无需if-else语句，也不需要RTTI。

    缺点1：仍然和实现方法1一样，加入一个新的子类后，需要在已有的类针对每种互动方法增加一个针对该类的互动方法，并在
新的类中针对所有已存在的类完善全部互动。

    bug1：当使用基类指针指向同类对象调用互动函数的时候会无限循环。
        比如： 基类 *p = &子类; 
              子类.fun(*p);//无限循环
              p->fun(子类)；//无限循环
    解决bug1的方法：在跳转函数中判断调用者的类型 和 参数的类型是否一致
        伪代码：    const type_info &objType = typeid(*this);
                    if(objType==typeid(子类)){
                        fun(static_cast<子类&>(参数对象));
                        return;
                    }


实现方法3：模仿虚函数表进行跳转
    和实现方式2相比,这种实现方式的具体场景是:已有的类不在乎新增的类如何运作,或者自己没有权限修改已有的类
    
    具体:当调用某个互动函数fun时，在跳转函数fun内根据传入参数查找虚函数表决定调用哪个实现函数。

    大概逻辑:(C是一个子类，obj是C类对象) obj.fun(子类)->C::fun(基类)->查表->C::funA(基类)
        伪代码:
            public:
            virtual void fun(基类 &){//跳转函数
                查表;
                调用;
            }
        private://注意下面的不再是fun,而是fun_A
            virtual void fun_A(基类&){和A的互动方式 }//实现函数
            ...
            virtual void fun_N(基类&){和N的互动方式}

    细节:1.虚函数表:
        1_1.重命名简化操作:虚函数表使用的是STL中的map,以string为key
            代码:value:typedef map<string,BlindingWhat_Ptr> BlendMap;
        1_2.虚函数表存在另一个函数lookup内,该函数负责初始化虚函数表,查表,返回函数指针
    具体逻辑:obj.fun(子类)->C::fun(基类)->lookup()->C::funA(基类)

    添加新类时:新增加一个类的时候只需要 1)完成和其他已有类的互动函数 2)在虚函数表增加类名+互动函数的指针 
                                3)在已有类中添加新增类的互动方式,在虚函数表增加类名+互动函数的指针
    优点:下标寻找的方式效率更好.
    缺点:每个类每种互动方式都要一个虚函数表.设有N个类K种互动,则有K*N个虚函数表
