M19指出了可能产生临时对象的3种情况:1.通过new创建.
                                2.通过函数传递产生
                                3.通过函数返回产生
注意:
    1.临时对象的产生意味着有构造和析构动作,这些动作都有一定的花销,有时候为了正确的代码逻辑
我们不得不接受这些花销,比如operator+就应该返回一个无名字的新对象,这个无名字的新对象就是一个临时变量.
    2.函数传递的过程如果产生了临时对象,那么该函数不应该有修改对象的功能,否则编译器会报错

M20指出为了得到正确的代码逻辑,一些临时变量的构造和析构代价是必要的.不应盲目为了效率产生奇怪的语法,
    如返回指针的话,会出现类似a=*(b+c)这样的语法

M21隐式转换
    使用隐式转换后我们也许会穷举所有可能出现的运算,比如char,int,long可以隐式转换为UPInt,那么我们也许
会为char写3个+,为int写3个+...这里就要重载9个operator+,然而还有-*/,这里重载9*3个函数很繁琐!
    因此在设计的时候,我们要根据8-2法则考虑清楚哪些操作是必要的,

M22赋值操作符=和其单独形式
    单独独形式即+-/*,赋值形式即+=,-=,*=,/=
    1.赋值形式效率会更高,因为使用+=的时候我们通常会把值赋给左边的对象,因此返回引用即可
    2.一个符号就有3次重载,如果有一点修改就要全部进行修改.因此我们把实际实现放在+=中,然后operator+
内部事实上调用的是+=。这样我们维护的时候只需要维护+=即可