_1MySmartPinter.cpp
介绍了如何自己写一个简单的智能指针,包括构造和析构、解引用。并在int main函数中进行简单的调用，可见其与普通指针的使用方法相似。


_2_PtrisNull
这个文件指出:智能指针无法判断自己是否指向一个空对象,为此提出解决方法
0.在智能指针类内增加isnull函数,这是可行的.但是会导致和普通指针操作方法不像！
1.进行类型转换,转换为void*后可以判断地址是否为空,此时发现可以判断是否指向空对象了
2.但是解决方法1引入一个新问题:不可知的比较结果。因为判断是否为空对象的时候实际上是判断地址是不是空的,如果有两个指针pa和pb,
pa和pb不必指向同一个对象,其结果是未知的。因为判断的时候回转换为void*,void*是内建类型,比对函数也是内建的,
所以无法按我们的需求正确对比pa和pb。

_3Smartptr2dump
这里指出在什么场景下需要从智能指针到dump指针的转换，哪些情况下可能会把智能指针转换成了dump指针
1.智能指针不能转到普通指针。  解决方法1：加入隐式转换
2.加入隐式转换后可以解决问题1，但可能会暴露dump指针,失去了智能指针的功能。
3.解决方法1也有一定局限，即隐式的转换智能进行一次，除非对象构造函数有智能指针作为参数。
4.走火入魔，真的把智能指针当dump指针，可能习惯性delete掉智能指针。

_4SmartPtr_vsDeriveAndBase
为了使智能指针和dump指针在多态情况具有相同的使用方法，提出一种基于模板的隐式转换
即以下代码段：
        template<class newType>
        operator smartPtr2<newType>(){ // 为了实现隐式类
            return smartPtr2<newType>(realPtr);
        }
以上代码解决了基于智能指针的多态，但是在多此继承的情况下可能出现二义性，
如：有以下继承关系，A-》B-》C，C即可以转换为B也可以转换为A，传入参数为父类智能指针的时候会出现二义性，如：
void Globalfun2(const smartPtr2<B>&);
smartPtr2<C> p=new C;
Globalfun2(p);
以上代码会出现二义性。

_5SmartPtr_VS_Const
为了让智能指针具备和dump指针那样和const的联动能力，提出了两种解决方案
1.使用隐式的转换,即文件中的smartPtr2
2.使用继承，即文件中的cleverPtr