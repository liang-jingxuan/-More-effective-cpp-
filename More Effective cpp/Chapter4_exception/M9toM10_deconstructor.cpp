//M9_析构函数中防止内存泄漏
    //1.在不得不适用指针的场合使用智能指针，这样即使出现异常导致没有执行后面的delete语句，
    //  也会因为throw退出当前函数而离开生存空间,然后调用智能指针的析构函数中对临时对象进行析构
    //好处:使用智能指针替代原始指针,就不再需要时刻记着new后delete,就算忘了也会自动析构,就算抛出异常了,在退出后会
    //自动析构
//M10_在构造函数中防止内存泄露
    //1.如果在构造函数函数体中抛出异常则对象并不完整,析构函数不会析构不万恒的对象.这种情况下使用智能指针是没用的
    //  经常用的方法是捕获所有的异常
    //2.一些成员必须使用初始化列表进行初始化时,异常可能在初始化中抛出.
    //  const指针就是不能改变指向的对象,所以不能再构造函数函数体内进行赋值,这时候必须初始化列表.
    //  经常用的方法是使用智能指针代替这些指针数据成员.
//M11_防止异常传递到析构函数外
    //调用析构的情况:1.使用delte或超过生存空间就调用析构.2.异常传递,比如以这样的堆栈进行析构 |A-B-C-D,|表示栈底
    //              如果D出现了异常,就传到C,C没有捕捉到就传到B...最后到A
    //情况2的破坏力比较大,因为会终止程序
    //解决办法:在有其他事情做的析构函数内进行异常捕捉try-catch,防止递归退出.catch里面不用写东西,能截止递归退出即可
