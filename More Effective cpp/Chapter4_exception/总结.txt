异常的运行规则
    抛出的异常有都有类型，一旦抛出异常，就会以出栈的形式退出函数寻找try-catch语句，
如果遇到的try-catch语块没有捕获到对应的类型,就会继续出栈退出.
****异常可能会导致内存泄露
//M9_析构函数中防止内存泄漏
    1.在不得不适用指针的场合使用智能指针，这样即使出现异常导致没有执行后面的delete语句，
      也会因为throw退出当前函数而离开生存空间,然后调用智能指针的析构函数中对临时对象进行析构
    好处:用智能指针代替所有需要用到指针的地方,这样就不用担心抛出异常无法执行delete
        也不用时时记着要delete某些东西.

//M10_在构造函数中防止内存泄露
    起因:
        对象的构造过程中,一旦因为异常导致构造函数未完整运行会导致构造出来的对象无法赋值,导致无法被析构.
    解决方法:
        为此,无论如何都要在构造函数里使用try-catch语句捕获所有可能的异常,确保构造函数顺利执行.
    改进:
        但是如果数据成员是const类型就只能使用初始化列表,这样没办法在函数体捕获异常,可以将try-catch
    封装起来在初始化列表中调用,但这样构造一个对象就要很多个分散的函数,因此最优解是使用智能指针
    结论:
        使用智能指针代替这些指针数据成员.

//M11_防止异常传递到析构函数外
    //调用析构的情况:1.使用delte或超过生存空间就调用析构.2.异常传递,比如以这样的堆栈进行析构 |A-B-C-D,|表示栈底
    //              如果D出现了异常,就传到C,C没有捕捉到就传到B...最后到A
    //情况2的破坏力比较大,因为会终止程序
    //解决办法:在有其他事情做的析构函数内进行异常捕捉try-catch,防止递归退出.catch里面不用写东西,能截止递归退出即可
